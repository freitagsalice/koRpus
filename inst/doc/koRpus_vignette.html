<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="m.eik michalke" />

<meta name="date" content="2018-03-07" />

<title>Using the koRpus Package for Text Analysis</title>

<meta name="flattr:id" content="4zdzgd" />


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

<style type="text/css">
  p.abstract{
    text-align: center;
    font-weight: bold;
  }
  div.abstract{
    margin: auto;
    width: 90%;
  }
</style>


<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">Using the koRpus Package for Text Analysis</h1>
<h4 class="author"><em>m.eik michalke</em></h4>
<h4 class="date"><em>2018-03-07</em></h4>
<div class="abstract">
<p class="abstract">Abstract</p>
<p>The R package <code>koRpus</code> aims to be a versatile tool for text analysis, with an emphasis on scientific research on that topic. It implements dozens of formulae to measure readability and lexical diversity. On a more basic level <code>koRpus</code> can be used as an R wrapper for third party products, like the tokenizer and POS tagger TreeTagger or language corpora of the Leipzig Corpora Collection. This vignette takes a brief tour around its core components, shows how they can be used and gives some insight on design decisions.</p>
</div>


<div id="TOC">
<ul>
<li><a href="#what-is-korpus">What is koRpus?</a></li>
<li><a href="#recommendations">Recommendations</a><ul>
<li><a href="#treetagger">TreeTagger</a></li>
<li><a href="#word-lists">Word lists</a></li>
<li><a href="#language-corpora">Language corpora</a></li>
<li><a href="#translated-human-rights-declaration">Translated Human Rights Declaration</a></li>
</ul></li>
<li><a href="#a-sample-session">A sample session</a><ul>
<li><a href="#loading-a-language-package">Loading a language package</a></li>
<li><a href="#tokenizing-and-pos-tagging">Tokenizing and POS tagging</a><ul>
<li><a href="#treetag"><code>treetag()</code></a></li>
<li><a href="#alternative-tokenize">Alternative: <code>tokenize()</code></a></li>
<li><a href="#accessing-data-from-korpus-objects">Accessing data from <code>koRpus</code> objects</a></li>
<li><a href="#descriptive-statistics">Descriptive statistics</a></li>
</ul></li>
<li><a href="#lexical-diversity-type-token-ratios">Lexical diversity (type token ratios)</a></li>
<li><a href="#frequency-analysis">Frequency analysis</a><ul>
<li><a href="#importing-language-corpora-data">Importing language corpora data</a></li>
<li><a href="#conduct-a-frequency-analysis">Conduct a frequency analysis</a></li>
<li><a href="#new-to-the-desc-slot">New to the <code>desc</code> slot</a></li>
</ul></li>
<li><a href="#readability">Readability</a><ul>
<li><a href="#readability-from-numeric-data">Readability from numeric data</a></li>
</ul></li>
<li><a href="#language-detection">Language detection</a></li>
</ul></li>
<li><a href="#extending-korpus">Extending <code>koRpus</code></a></li>
<li><a href="#analyzing-full-corpora">Analyzing full corpora</a></li>
<li><a href="#acknowledgements">Acknowledgements</a></li>
<li><a href="#references">References</a></li>
</ul>
</div>

<div id="what-is-korpus" class="section level1">
<h1>What is koRpus?</h1>
<p>Work on <code>koRpus</code> started in February 2011, primarily with the goal in mind to examine how similar different texts are. Since then, it quickly grew into an R package which implements dozens of formulae for readability and lexical diversity, and wrappers for language corpus databases and a tokenizer/POS tagger.</p>
</div>
<div id="recommendations" class="section level1">
<h1>Recommendations</h1>
<div id="treetagger" class="section level2">
<h2>TreeTagger</h2>
<p>At the very beginning of almost every analysis with this package, the text you want to examine has to be sliced into its components, and the components must be identified and named. That is, it has to be split into its semantic parts (tokens), words, numbers, punctuation marks. After that, each token will be tagged regarding its part-of-speech (POS). For both of these steps, <code>koRpus</code> can use the third party software <a href="http://www.ims.uni-stuttgart.de/projekte/corplex/TreeTagger/DecisionTreeTagger.html">TreeTagger</a> <span class="citation">(Schmid, 1994)</span>.</p>
<p>Especially for Windows users installation of TreeTagger might be a little more complex – e.g., it depends on Perl<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>, and you need a tool to extract .tar.gz archives.<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> Detailed installations instructions are beyond the scope of this vignette.</p>
<p>If you don’t want to use TreeTagger, <code>koRpus</code> provides a simple tokenizer of its own called <code>tokenize()</code>. While the tokenizing itself works quite well, <code>tokenize()</code> is not as elaborate as is TreeTagger when it comes to POS tagging, as it can merely tell words from numbers, punctuation and abbreviations. Although this is sufficient for most readability formulae, you can’t evaluate word classes in detail. If that’s what you want, a TreeTagger installation is needed.</p>
</div>
<div id="word-lists" class="section level2">
<h2>Word lists</h2>
<p>Some of the readability formulae depend on special word lists <span class="citation">(like Bormuth, 1968; Dale &amp; Chall, 1948; Spache, 1953)</span>. For copyright reasons these lists are not included as of now. This means, as long as you don’t have copies of these lists, you can’t calculate these particular measures, but of course all others. The expected format to use a list with this package is a simple text file with one word per line, preferably in UTF-8 encoding.</p>
</div>
<div id="language-corpora" class="section level2">
<h2>Language corpora</h2>
<p>The frequency analysis functions in this package can look up how often each word in a text is used in its language, given that a corpus database is provided. Databases in Celex format are support, as is the Leipzig Corpora Collection <span class="citation">(Quasthoff, Richter, &amp; Biemann, 2006)</span> file format. To use such a database with this package, you simply need to download one of the .zip/.tar files.</p>
</div>
<div id="translated-human-rights-declaration" class="section level2">
<h2>Translated Human Rights Declaration</h2>
<p>If you want to estimate the language of a text, reference texts in known languages are needed. In <code>koRpus</code>, the <a href="https://www.unicode.org/udhr/downloads.html">Universal Declaration of Human Rights with its more than 350 translations</a> is used.</p>
</div>
</div>
<div id="a-sample-session" class="section level1">
<h1>A sample session</h1>
<p>From now on it is assumed that the above requirements are correctly installed and working. If an optional component is used it will be noted. Further, we’ll need a sample text to analyze. We’ll use the section on <a href="http://en.wikipedia.org/wiki/Phasmatodea#Defense_mechanisms">defense mechanisms of Phasmatodea</a> from Wikipedia for this purpose.</p>
<div id="loading-a-language-package" class="section level2">
<h2>Loading a language package</h2>
<p>In order to do some analysis, you need to load a language support package for each language you would like to work with. For instance, in this vignette we’re analyzing an English sample text. Language support packages for <code>koRpus</code> are named <code>koRpus.lang.**</code>, where <code>**</code> is a two-character ID for the respective language, like <code>en</code> for English.<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># install the language support package</span>
<span class="kw">install.koRpus.lang</span>(<span class="st">&quot;en&quot;</span>)
<span class="co"># load the package</span>
<span class="kw">library</span>(koRpus.lang.en)</code></pre></div>
<p>When <code>koRpus</code> itself is loaded, it will list you all language packages found on your system. To get a list of all installable packages, call <code>available.koRpus.lang()</code>.</p>
</div>
<div id="tokenizing-and-pos-tagging" class="section level2">
<h2>Tokenizing and POS tagging</h2>
<p>As explained earlier, splitting the text up into its basic components can be done by TreeTagger. To achieve this and have the results available in R, the function <code>treetag()</code> is used.</p>
<div id="treetag" class="section level3">
<h3><code>treetag()</code></h3>
<p>At the very least you must provide it with the text, of course, and name the language it is written in. In addition to that you must specify where you installed TreeTagger. If you look at the package documentation you’ll see that <code>treetag()</code> understands a number of options to configure TreeTagger, but in most cases using one of the built-in presets should suffice. TreeTagger comes with batch/shell scripts for installed languages, and the presets of <code>treetag()</code> are basically just R implementations of these scripts.</p>
<!--
  we can't evaluate this code if the package should go to CRAN
  because TreeTagger will not be present.
-->
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">tagged.text &lt;-<span class="st"> </span><span class="kw">treetag</span>(
  <span class="st">&quot;sample_text.txt&quot;</span>,
  <span class="dt">treetagger=</span><span class="st">&quot;manual&quot;</span>,
  <span class="dt">lang=</span><span class="st">&quot;en&quot;</span>,
  <span class="dt">TT.options=</span><span class="kw">list</span>(
    <span class="dt">path=</span><span class="st">&quot;~/bin/treetagger/&quot;</span>,
    <span class="dt">preset=</span><span class="st">&quot;en&quot;</span>
  ),
  <span class="dt">doc_id=</span><span class="st">&quot;sample&quot;</span>
)</code></pre></div>
<!--
  we work around that issue by silently loading the tagged text from a dput file
-->
<p>The first argument (file name) and <code>lang</code> should explain themselves. The <code>treetagger</code> option can either take the full path to one of the original TreeTagger scripts mentioned above, or the keyword “manual”, which will cause the interpretation of what is defined by <code>TT.options</code>. To use a preset, just put the <code>path</code> to your local TreeTagger installation and a valid <code>preset</code> name here.<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a> The document ID is optional and can be omitted.</p>
<p>The resulting S4 object is of a class called <code>kRp.tagged</code>. If you call the object directly you get a shortened view of it’s main content:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">tagged.text</code></pre></div>
<pre><code>##     doc_id       token  tag     lemma lttr      wclass desc stop stem idx sntc
## 1   sample     Defense   NN   defense    7        noun &lt;NA&gt; &lt;NA&gt; &lt;NA&gt;   1    1
## 2   sample  mechanisms  NNS mechanism   10        noun &lt;NA&gt; &lt;NA&gt; &lt;NA&gt;   2    1
## 3   sample Phasmatodea   NP &lt;unknown&gt;   11        name &lt;NA&gt; &lt;NA&gt; &lt;NA&gt;   3    1
## 4   sample     species   NN   species    7        noun &lt;NA&gt; &lt;NA&gt; &lt;NA&gt;   4    1
## 5   sample     exhibit   NN   exhibit    7        noun &lt;NA&gt; &lt;NA&gt; &lt;NA&gt;   5    1
## 6   sample  mechanisms  NNS mechanism   10        noun &lt;NA&gt; &lt;NA&gt; &lt;NA&gt;   6    1
##                                                  [...]                        
## 612 sample  considered  VBN  consider   10        verb &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; 612   18
## 613 sample    inedible   JJ  inedible    8   adjective &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; 613   18
## 614 sample          by   IN        by    2 preposition &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; 614   18
## 615 sample        some   DT      some    4  determiner &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; 615   18
## 616 sample   predators  NNS  predator    9        noun &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; 616   18
## 617 sample           . SENT         .    1    fullstop &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; 617   18</code></pre>
<p>Once you’ve come this far, i.e., having a valid object of class <code>kRp.tagged</code>, all following analyses should run smoothly.</p>
<div id="troubleshooting" class="section level4">
<h4>Troubleshooting</h4>
<p>If <code>treetag()</code> should fail, you should first re-run it with the extra option <code>debug=TRUE</code>. Most interestingly, that will print the contents of <code>sys.tt.call</code>, which is the TreeTagger command given to your operating system for execution. With that it should be possible to examine where exactly the erroneous behavior starts.</p>
</div>
</div>
<div id="alternative-tokenize" class="section level3">
<h3>Alternative: <code>tokenize()</code></h3>
<p>If you don’t need detailed word class analysis, you should be fine using <code>koRpus</code>’ own function <code>tokenize()</code>. As you can see, <code>tokenize()</code> comes to the same results regarding the tokens, but is rather limited in recognizing word classes:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(tokenized.text &lt;-<span class="st"> </span><span class="kw">tokenize</span>(
    <span class="st">&quot;sample_text.txt&quot;</span>,
    <span class="dt">lang=</span><span class="st">&quot;en&quot;</span>,
    <span class="dt">doc_id=</span><span class="st">&quot;sample&quot;</span>
))</code></pre></div>
<pre><code>##     doc_id       token      tag lemma lttr   wclass desc stop stem idx sntc
## 1   sample     Defense word.kRp          7     word &lt;NA&gt; &lt;NA&gt; &lt;NA&gt;   1    1
## 2   sample  mechanisms word.kRp         10     word &lt;NA&gt; &lt;NA&gt; &lt;NA&gt;   2    1
## 3   sample Phasmatodea word.kRp         11     word &lt;NA&gt; &lt;NA&gt; &lt;NA&gt;   3    1
## 4   sample     species word.kRp          7     word &lt;NA&gt; &lt;NA&gt; &lt;NA&gt;   4    1
## 5   sample     exhibit word.kRp          7     word &lt;NA&gt; &lt;NA&gt; &lt;NA&gt;   5    1
## 6   sample  mechanisms word.kRp         10     word &lt;NA&gt; &lt;NA&gt; &lt;NA&gt;   6    1
##                                               [...]                        
## 620 sample  considered word.kRp         10     word &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; 620   20
## 621 sample    inedible word.kRp          8     word &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; 621   20
## 622 sample          by word.kRp          2     word &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; 622   20
## 623 sample        some word.kRp          4     word &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; 623   20
## 624 sample   predators word.kRp          9     word &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; 624   20
## 625 sample           .     .kRp          1 fullstop &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; 625   20</code></pre>
</div>
<div id="accessing-data-from-korpus-objects" class="section level3">
<h3>Accessing data from <code>koRpus</code> objects</h3>
<p>For this class of objects, <code>koRpus</code> provides some comfortable methods to extract the portions you’re interested in. For example, the main results are to be found in the slot <code>TT.res</code>. In addition to TreeTagger’s original output (token, tag and lemma) <code>treetag()</code> also automatically counts letters and assigns tokens to global word classes. To get these results as a data.frame, use the getter method <code>taggedText()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">taggedText</span>(tagged.text)[<span class="dv">26</span>:<span class="dv">34</span>,]</code></pre></div>
<pre><code>##    doc_id     token tag    lemma lttr      wclass desc stop stem idx sntc
## 26 sample       and  CC      and    3 conjunction   NA   NA   NA  26    1
## 27 sample       are VBP       be    3        verb   NA   NA   NA  27    1
## 28 sample  deployed VBN   deploy    8        verb   NA   NA   NA  28    1
## 29 sample     after  IN    after    5 preposition   NA   NA   NA  29    1
## 30 sample        an  DT       an    2  determiner   NA   NA   NA  30    1
## 31 sample    attack  NN   attack    6        noun   NA   NA   NA  31    1
## 32 sample       has VBZ     have    3        verb   NA   NA   NA  32    1
## 33 sample      been VBN       be    4        verb   NA   NA   NA  33    1
## 34 sample initiated VBN initiate    9        verb   NA   NA   NA  34    1</code></pre>
<p>In case you want to access a subset of the data in the resulting object, e.g., only the column with number of letters or the first five rows of <code>TT.res</code>, you’ll be happy to know there’s special <code>[</code> and <code>[[</code> methods for these kinds of objects:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(tagged.text[[<span class="st">&quot;lttr&quot;</span>]], <span class="dt">n=</span><span class="dv">50</span>)</code></pre></div>
<pre><code>##  [1]  7 10 11  7  7 10  3  7  4  9  4  4  7  2  6  4  9  2  3  5  5  1  7  7  1  3  3
## [28]  8  5  2  6  3  4  9  1  9  8  1  3  7  9  4  7 12  4 11  2 10  1  4</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">tagged.text[<span class="dv">1</span>:<span class="dv">5</span>,]</code></pre></div>
<pre><code>##   doc_id       token tag     lemma lttr wclass desc stop stem idx sntc
## 1 sample     Defense  NN   defense    7   noun   NA   NA   NA   1    1
## 2 sample  mechanisms NNS mechanism   10   noun   NA   NA   NA   2    1
## 3 sample Phasmatodea  NP &lt;unknown&gt;   11   name   NA   NA   NA   3    1
## 4 sample     species  NN   species    7   noun   NA   NA   NA   4    1
## 5 sample     exhibit  NN   exhibit    7   noun   NA   NA   NA   5    1</code></pre>
<p>The <code>[</code> and <code>[[</code> methods are basically a useful shortcut replacements for <code>taggedText()</code>.</p>
</div>
<div id="descriptive-statistics" class="section level3">
<h3>Descriptive statistics</h3>
<p>All results of both <code>treetag()</code> and <code>tokenize()</code> also provide various descriptive statistics calculated from the analyzed text. You can get them by calling <code>describe()</code> on the object:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">describe</span>(tagged.text)</code></pre></div>
<pre><code>## $all.chars
## [1] 3554
## 
## $lines
## [1] 10
## 
## $normalized.space
## [1] 3549
## 
## $chars.no.space
## [1] 2996
## 
## $punct
## [1] 78
## 
## $digits
## [1] 4
## 
## $letters
##  all   l1   l2   l3   l4   l5   l6   l7   l8   l9  l10  l11  l12  l13  l14  l15  l16 
## 2918   19   92   74   80   51   49   65   43   35   22   15    6    3    0    1    1 
## 
## $letters.only
## [1] 2914
## 
## $char.distrib
##                 1         2         3         4          5          6         7
## num      80.00000  92.00000  74.00000  80.00000  51.000000  49.000000  65.00000
## cum.sum  80.00000 172.00000 246.00000 326.00000 377.000000 426.000000 491.00000
## cum.inv 537.00000 445.00000 371.00000 291.00000 240.000000 191.000000 126.00000
## pct      12.96596  14.91086  11.99352  12.96596   8.265802   7.941653  10.53485
## cum.pct  12.96596  27.87682  39.87034  52.83630  61.102107  69.043760  79.57861
## pct.inv  87.03404  72.12318  60.12966  47.16370  38.897893  30.956240  20.42139
##                  8          9         10         11          12          13
## num      43.000000  35.000000  22.000000  15.000000   6.0000000   3.0000000
## cum.sum 534.000000 569.000000 591.000000 606.000000 612.0000000 615.0000000
## cum.inv  83.000000  48.000000  26.000000  11.000000   5.0000000   2.0000000
## pct       6.969206   5.672609   3.565640   2.431118   0.9724473   0.4862237
## cum.pct  86.547812  92.220421  95.786062  98.217180  99.1896272  99.6758509
## pct.inv  13.452188   7.779579   4.213938   1.782820   0.8103728   0.3241491
##                  14          15          16
## num       0.0000000   1.0000000   1.0000000
## cum.sum 615.0000000 616.0000000 617.0000000
## cum.inv   2.0000000   1.0000000   0.0000000
## pct       0.0000000   0.1620746   0.1620746
## cum.pct  99.6758509  99.8379254 100.0000000
## pct.inv   0.3241491   0.1620746   0.0000000
## 
## $lttr.distrib
##                  1         2         3         4          5         6         7
## num      19.000000  92.00000  74.00000  80.00000  51.000000  49.00000  65.00000
## cum.sum  19.000000 111.00000 185.00000 265.00000 316.000000 365.00000 430.00000
## cum.inv 537.000000 445.00000 371.00000 291.00000 240.000000 191.00000 126.00000
## pct       3.417266  16.54676  13.30935  14.38849   9.172662   8.81295  11.69065
## cum.pct   3.417266  19.96403  33.27338  47.66187  56.834532  65.64748  77.33813
## pct.inv  96.582734  80.03597  66.72662  52.33813  43.165468  34.35252  22.66187
##                  8          9         10         11          12          13
## num      43.000000  35.000000  22.000000  15.000000   6.0000000   3.0000000
## cum.sum 473.000000 508.000000 530.000000 545.000000 551.0000000 554.0000000
## cum.inv  83.000000  48.000000  26.000000  11.000000   5.0000000   2.0000000
## pct       7.733813   6.294964   3.956835   2.697842   1.0791367   0.5395683
## cum.pct  85.071942  91.366906  95.323741  98.021583  99.1007194  99.6402878
## pct.inv  14.928058   8.633094   4.676259   1.978417   0.8992806   0.3597122
##                  14          15          16
## num       0.0000000   1.0000000   1.0000000
## cum.sum 554.0000000 555.0000000 556.0000000
## cum.inv   2.0000000   1.0000000   0.0000000
## pct       0.0000000   0.1798561   0.1798561
## cum.pct  99.6402878  99.8201439 100.0000000
## pct.inv   0.3597122   0.1798561   0.0000000
## 
## $words
## [1] 556
## 
## $sentences
## [1] 18
## 
## $avg.sentc.length
## [1] 30.88889
## 
## $avg.word.length
## [1] 5.248201
## 
## $doc_id
## [1] &quot;sample&quot;</code></pre>
<p>Amongst others, you will find several indices describing the number of characters:</p>
<ul>
<li><code>all.chars</code>: Counts each character, including all space characters</li>
<li><code>normalized.space</code>: Like <code>all.chars</code>, but clusters of space characters (incl. line breaks) are counted only as one character</li>
<li><code>chars.no.space</code>: Counts all characters except any space characters</li>
<li><code>letters.only</code>: Counts only letters, excluding(!) digits (which are counted seperately as <code>digits</code>)</li>
</ul>
<p>You’ll also find the number of <code>words</code> and <code>sentences</code>, as well as average word and sentence lengths, and tables describing how the word length is distributed throughout the text (<code>lttr.distrib</code>). For instance, we see that the text has 74 words with three letters, 185 with three or less, and 371 with more than three. The last three lines show the percentages, respectively.</p>
</div>
</div>
<div id="lexical-diversity-type-token-ratios" class="section level2">
<h2>Lexical diversity (type token ratios)</h2>
<p>To analyze the lexical diversity of our text we can now simply hand over the tagged text object to the <code>lex.div()</code> method. You can call it on the object with no further arguments (like <code>lex.div(tagged.text)</code>), but in this example we’ll limit the analysis to a few measures:<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">lex.div</span>(
  tagged.text,
  <span class="dt">measure=</span><span class="kw">c</span>(<span class="st">&quot;TTR&quot;</span>, <span class="st">&quot;MSTTR&quot;</span>, <span class="st">&quot;MATTR&quot;</span>,<span class="st">&quot;HD-D&quot;</span>, <span class="st">&quot;MTLD&quot;</span>, <span class="st">&quot;MTLD-MA&quot;</span>),
  <span class="dt">char=</span><span class="kw">c</span>(<span class="st">&quot;TTR&quot;</span>, <span class="st">&quot;MATTR&quot;</span>,<span class="st">&quot;HD-D&quot;</span>, <span class="st">&quot;MTLD&quot;</span>, <span class="st">&quot;MTLD-MA&quot;</span>)
)</code></pre></div>
<!-- the status bars ruin the document, silencing them for the actual output -->
<pre><code>## 
## Total number of tokens: 556
## Total number of types:  294
## Total number of lemmas: 283
## 
## Type-Token Ratio
##    TTR: 0.53 
## 
## TTR characteristics:
##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##  0.5297  0.5466  0.5930  0.6188  0.6491  1.0000 
##    SD
##  0.0907
## 
## 
## Mean Segmental Type-Token Ratio
##                MSTTR: 0.72
##           SD of TTRs: 0.03
##         Segment size: 100
##       Tokens dropped: 56 
## 
## Hint: A segment size of 92 would reduce the drop rate to 4.
##       Maybe try ?segment.optimizer()
## 
## 
## Moving-Average Type-Token Ratio
##                MATTR: 0.74
##           SD of TTRs: 0.03
##          Window size: 100 
## 
## MATTR characteristics:
##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##  0.7138  0.7239  0.7308  0.7290  0.7341  0.7368 
##    SD
##  0.0066
## 
## 
## HD-D
##           HD-D: 35.54
##           ATTR: 0.85
##    Sample size: 42 
## 
## HD-D characteristics:
##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##    5.00   35.46   35.62   34.31   35.82   36.16 
##    SD
##  5.0648
## 
## 
## Measure of Textual Lexical Diversity
##                 MTLD: 97.38
##    Number of factors: 5.71
##          Factor size: 0.72
##     SD tokens/factor: 36.08 (all factors)
##                       26.06 (complete factors only)
## 
## MTLD characteristics:
##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's 
##   14.00   79.07   88.37   83.21   92.92  104.40       1 
##    SD
##  15.9015
## 
## 
## Moving-Average Measure of Textual Lexical Diversity
##              MTLD-MA: 102.73
##     SD tokens/factor: 26.74
##            Step size: 1
##          Factor size: 0.72
##          Min. tokens: 9 
## 
## MTLD-MA characteristics:
##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's 
##   63.00   92.99   96.57   95.89  102.76  107.99      12 
##    SD
##  9.6766</code></pre>
<pre><code>## 
## Note: Analysis was conducted case insensitive.</code></pre>
<p>Let’s look at some particular parts: At first we are informed of the total number of types, tokens and lemmas (if available). After that the actual results are being printed, using the package’s <code>show()</code> method for this particular kind of object. As you can see, it prints the actual value of each measure before a summary of the characteristics.<a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a></p>
<p>Some measures return more information than just their actual index value. For instance, when the Mean Segmental Type-Token Ratio is calculated, you’ll be informed how much of your text was dropped and hence not examined. A small feature tool of <code>koRpus</code>, <code>segment.optimizer()</code>, automatically recommends you with a different segment size if this could decrease the number of lost tokens.</p>
<p>By default, <code>lex.div()</code> calculates every measure of lexical diversity that was implemented. Of course this is fully configurable, e.g. to completely skip the calculation of characteristics just add the option <code>char=NULL</code>. If you’re only interested in one particular measure, it might be more convenient to call the according wrapper function instead of <code>lex.div()</code>. For example, to calculate only the measures proposed by <span class="citation">Maas (1972)</span>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">maas</span>(tagged.text)</code></pre></div>
<pre><code>## Language: &quot;en&quot;</code></pre>
<pre><code>## 
## Total number of tokens: 556
## Total number of types:  294
## Total number of lemmas: 283
## 
## Maas' Indices
##        a: 0.19 
##     lgV0: 5.64 
##    lgeV0: 12.99 
## 
## Relative vocabulary growth (first half to full text)
##        a: 0.81 
##     lgV0: 6.75 
##       V': 0.43 (43 new types every 100 tokens)</code></pre>
<pre><code>## 
## Note: Analysis was conducted case insensitive.</code></pre>
<p>All wrapper functions have characteristics turned off by default. The following example demonstrates how to calculate and plot the classic type-token ratio with characteristics. The resulting plot shows the typical degredation of TTR values with increasing text length:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ttr.res &lt;-<span class="st"> </span><span class="kw">TTR</span>(tagged.text, <span class="dt">char=</span><span class="ot">TRUE</span>)
<span class="kw">plot</span>(ttr.res@TTR.char, <span class="dt">type=</span><span class="st">&quot;l&quot;</span>, <span class="dt">main=</span><span class="st">&quot;TTR degredation over text length&quot;</span>)</code></pre></div>
<!-- same here silencing the status bars -->
<p><img src="data:image/png;base64,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" /><!-- --></p>
<p>Since this package is intended for research, it is possible to directly influence all relevant values of each measure and examine the effects. For example, as mentioned before <code>segment.optimizer()</code> recommended a change of segment size for MSTTR to drop less words, which is easily done:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">MSTTR</span>(tagged.text, <span class="dt">segment=</span><span class="dv">92</span>)</code></pre></div>
<pre><code>## Language: &quot;en&quot;</code></pre>
<pre><code>## 
## Total number of tokens: 556
## Total number of types:  294
## Total number of lemmas: 283
## 
## Mean Segmental Type-Token Ratio
##                MSTTR: 0.75
##           SD of TTRs: 0.04
##         Segment size: 92
##       Tokens dropped: 4</code></pre>
<pre><code>## 
## Note: Analysis was conducted case insensitive.</code></pre>
<p>Please see to the documentation for more detailed information on the available measures and their references.</p>
</div>
<div id="frequency-analysis" class="section level2">
<h2>Frequency analysis</h2>
<div id="importing-language-corpora-data" class="section level3">
<h3>Importing language corpora data</h3>
<p>This package has rudimentary support to import corpus databases.<a href="#fn7" class="footnoteRef" id="fnref7"><sup>7</sup></a> That is, it can read frequency data for words into an R object and use this object for further analysis. Next to the <a href="http://celex.mpi.nl">Celex</a> database format (<code>read.corp.celex()</code>), it can read the LCC flatfile format<a href="#fn8" class="footnoteRef" id="fnref8"><sup>8</sup></a> (<code>read.corp.LCC()</code>). The latter might be of special interest, because the needed database archives can be <a href="http://corpora.informatik.uni-leipzig.de/download.html">freely downloaded</a>. Once you’ve downloaded one of these archives, it can be comfortably imported:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">LCC.en &lt;-<span class="st"> </span><span class="kw">read.corp.LCC</span>(<span class="st">&quot;~/downloads/corpora/eng_news_2010_1M-text.tar&quot;</span>)</code></pre></div>
<p><code>read.corp.LCC()</code> will automatically extract the files it needs from the archive. Alernatively, you can specify the path to the unpacked archive as well. To work with the imported data directly, the tool <code>query()</code> was added to the package. It helps you to comfortably look up certain words, or ranges of interesting values:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">query</span>(LCC.en, <span class="st">&quot;word&quot;</span>, <span class="st">&quot;what&quot;</span>)</code></pre></div>
<!-- we need to fake these results, as there will not be a corpus database around -->
<pre><code>##     num word  freq         pct pmio    log10 rank.avg rank.min rank.rel.avg
## 160 210 what 16396 0.000780145  780 2.892095   260759   260759     99.95362
##     rank.rel.min
## 160     99.95362</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">query</span>(LCC.en, <span class="st">&quot;pmio&quot;</span>, <span class="kw">c</span>(<span class="dv">780</span>, <span class="dv">790</span>))</code></pre></div>
<pre><code>##     num  word  freq          pct pmio    log10 rank.avg rank.min rank.rel.avg
## 156 206  many 16588 0.0007892806  789 2.897077   260763   260763     99.95515
## 157 207   per 16492 0.0007847128  784 2.894316   260762   260762     99.95477
## 158 208  down 16468 0.0007835708  783 2.893762   260761   260761     99.95439
## 159 209 since 16431 0.0007818103  781 2.892651   260760   260760     99.95400
## 160 210  what 16396 0.0007801450  780 2.892095   260759   260759     99.95362
##     rank.rel.min
## 156     99.95515
## 157     99.95477
## 158     99.95439
## 159     99.95400
## 160     99.95362</code></pre>
</div>
<div id="conduct-a-frequency-analysis" class="section level3">
<h3>Conduct a frequency analysis</h3>
<p>We can now conduct a full frequency analysis of our text:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">freq.analysis.res &lt;-<span class="st"> </span><span class="kw">freq.analysis</span>(tagged.text, <span class="dt">corp.freq=</span>LCC.en)</code></pre></div>
<p>The resulting object holds a lot of information, even if no corpus data was used (i.e., <code>corp.freq=NULL</code>). To begin with, it contains the two slots <code>TT.res</code> and <code>lang</code>, which are copied from the analyzed tagged text object. In this way analysis results can always be converted back into <code>kRp.tagged</code> objects.<a href="#fn9" class="footnoteRef" id="fnref9"><sup>9</sup></a> However, if corpus data was provided, the tagging results gained three new columns:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">taggedText</span>(freq.analysis.res)</code></pre></div>
<pre><code>##        token tag     lemma lttr  [...] pmio rank.avg rank.min
[...]
## 30        an  DT        an    2        3817 99.98735 99.98735
## 31    attack  NN    attack    6         163 99.70370 99.70370
## 32       has VBZ      have    3        4318 99.98888 99.98888
## 33      been VBN        be    4        2488 99.98313 99.98313
## 34 initiated VBN  initiate    9          11 97.32617 97.32137
## 35         (   (         (    1         854 99.96013 99.96013
## 36 secondary  JJ secondary    9          21 98.23846 98.23674
## 37   defense  NN   defense    7         210 99.77499 99.77499
## 38         )   )         )    1         856 99.96052 99.96052
[...]</code></pre>
<p>Perhaps most informatively, <code>pmio</code> shows how often the respective token appears in a million tokens, according to the corpus data. Adding to this, the previously introduced slot <code>desc</code> now contains some more descriptive statistics on our text, and if we provided a corpus database, the slot <code>freq.analysis</code> lists summaries of various frequency information that was calculated.</p>
<p>If the corpus object also provided inverse document frequency (i.e., values in column <code>idf</code>) data, <code>freq.analysis()</code> will automatically compute tf-idf statistics and put them in a column called <code>tfidf</code>.</p>
</div>
<div id="new-to-the-desc-slot" class="section level3">
<h3>New to the <code>desc</code> slot</h3>
<p>Amongst others, the descriptives now also give easy access to character vectors with all words (<code>$all.words</code>) and all lemmata (<code>$all.lemmata</code>), all tokens sorted<a href="#fn10" class="footnoteRef" id="fnref10"><sup>10</sup></a> into word classes (e.g., all verbs in <code>$classes$verb</code>), or the number of words in each sentece:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">describe</span>(freq.analysis.res)[[<span class="st">&quot;sentc.length&quot;</span>]]</code></pre></div>
<pre><code>##  [1] 34 10 37 16 44 31 14 31 34 23 17 43 40 47 22 19 65 29</code></pre>
<p>As a practical example, the list <code>$classes</code> has proven to be very helpful to debug the results of TreeTagger, which is remarkably accurate, but of course not free from making a mistake now and then. By looking through <code>$classes</code>, where all tokens are grouped regarding to the global word class TreeTagger attributed to it, at least obvious errors (like names mistakenly taken for a pronoun) are easily found:<a href="#fn11" class="footnoteRef" id="fnref11"><sup>11</sup></a></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">describe</span>(freq.analysis.res)$classes</code></pre></div>
<pre><code>## $conjunction
## [1] &quot;both&quot; &quot;and&quot;  &quot;and&quot;  &quot;and&quot;  &quot;and&quot;  &quot;or&quot;   &quot;or&quot;   &quot;and&quot;  &quot;and&quot;  &quot;or&quot;  
## [11] &quot;and&quot;  &quot;or&quot;   &quot;and&quot;  &quot;or&quot;   &quot;and&quot;  &quot;and&quot;  &quot;and&quot;  &quot;and&quot; 
## 
## $number
## [1] &quot;20&quot;  &quot;one&quot;
## 
## $determiner
##  [1] &quot;an&quot;      &quot;the&quot;     &quot;an&quot;      &quot;The&quot;     &quot;the&quot;     &quot;the&quot;     &quot;some&quot;   
##  [8] &quot;that&quot;    &quot;Some&quot;    &quot;the&quot;     &quot;a&quot;       &quot;a&quot;       &quot;a&quot;       &quot;the&quot;    
## [15] &quot;that&quot;    &quot;the&quot;     &quot;the&quot;     &quot;Another&quot; &quot;which&quot;   &quot;the&quot;     &quot;a&quot;      
## [22] &quot;that&quot;    &quot;a&quot;       &quot;The&quot;     &quot;a&quot;       &quot;the&quot;     &quot;that&quot;    &quot;a&quot;      
[...]</code></pre>
</div>
</div>
<div id="readability" class="section level2">
<h2>Readability</h2>
<p>The package comes with implementations of several readability formulae. Some of them depend on the number of syllables in the text.<a href="#fn12" class="footnoteRef" id="fnref12"><sup>12</sup></a> To achieve this, the method <code>hyphen()</code> takes objects of class <code>kRp.tagged</code> and applies an hyphenation algorithm <span class="citation">(Liang, 1983)</span> to each word. This algorithm was originally developed for automatic word hyphenation in <span class="math inline">\(\LaTeX\)</span>, and is gracefully misused here to fulfill a slightly different service.<a href="#fn13" class="footnoteRef" id="fnref13"><sup>13</sup></a></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(hyph.txt.en &lt;-<span class="st"> </span><span class="kw">hyphen</span>(tagged.text))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">hyph.txt.en</code></pre></div>
<pre><code>##     syll           word
## 1      2       De-fense
## 2      3   mech-a-nisms
## 3      4 Phasm-a-to-dea
## 4      2       spe-cies
## 5      3      ex-hib-it
## 6      3   mech-a-nisms
##       NA      [...]    
## 551    1             is
## 552    3   con-sid-ered
## 553    4    in-ed-i-ble
## 554    1             by
## 555    1           some
## 556    3    pred-a-tors</code></pre>
<p>This seperate hyphenation step can actually be skipped, as <code>readability()</code> will do it automatically if needed. But similar to TreeTagger, <code>hyphen()</code> will most likely not produce perfect results. As a rule of thumb, if in doubt it seems to behave rather conservative, that is, is underestimates the real number of syllables in a text. This, however, would of course affect the results of several readability formulae.</p>
<p>So, the more accurate the end results should be, the less you should rely on the automatic hyphenation alone. But it sure is a good starting point, for there is a method called <code>correct.hyph()</code> to help you clean these results of errors later on. The most straight forward way to do this is to call <code>hyphenText(hyph.txt.en)</code>, which will get you a data frame with two colums, <code>word</code> (the hyphenated words) and <code>syll</code> (the number of syllables), in a spread sheet editor:<a href="#fn14" class="footnoteRef" id="fnref14"><sup>14</sup></a></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(<span class="kw">hyphenText</span>(hyph.txt.en))</code></pre></div>
<pre><code>##   syll           word
## 1    2       De-fense
## 2    3   mech-a-nisms
## 3    4 Phasm-a-to-dea
## 4    2       spe-cies
## 5    3      ex-hib-it
## 6    3   mech-a-nisms</code></pre>
<p>You can then manually correct wrong hyphenations by removing or inserting “-” as hyphenation indicators, and call <code>correct.hyph()</code> without further arguments, which will cause it to recount all syllables:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">hyph.txt.en &lt;-<span class="st"> </span><span class="kw">correct.hyph</span>(hyph.txt.en)</code></pre></div>
<p>But the method can also be used to alter entries directly, which might be simpler and cleaner than manual changes:</p>
<!-- this can cause errors if updated hyphen patterns lead to slighty different results in the first place -->
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">hyph.txt.en &lt;-<span class="st"> </span><span class="kw">correct.hyph</span>(hyph.txt.en, <span class="dt">word=</span><span class="st">&quot;mech-a-nisms&quot;</span>, <span class="dt">hyphen=</span><span class="st">&quot;mech-a-ni-sms&quot;</span>)</code></pre></div>
<pre><code>## Changed
## 
##   syll         word
## 2    3 mech-a-nisms
## 6    3 mech-a-nisms
## 
##   into
## 
##   syll          word
## 2    4 mech-a-ni-sms
## 6    4 mech-a-ni-sms</code></pre>
<p>The hyphenated text object can now be given to <code>readability()</code>, to calculate the measures of interest:<a href="#fn15" class="footnoteRef" id="fnref15"><sup>15</sup></a></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">readbl.txt &lt;-<span class="st"> </span><span class="kw">readability</span>(tagged.text, <span class="dt">hyphen=</span>hyph.txt.en)</code></pre></div>
<p>Similar to <code>lex.div()</code>, by default <code>readability()</code> calculates almost<a href="#fn16" class="footnoteRef" id="fnref16"><sup>16</sup></a> all available measures:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">readbl.txt</code></pre></div>
<pre><code>## 
## Automated Readability Index (ARI)
##   Parameters: default 
##        Grade: 18.73 
## 
## 
## Coleman Formulas
##   Parameters: default 
##     Pronouns: 1.62 (per 100 words)
##      Prepos.: 13.49 (per 100 words)
##    Formula 1: 39% cloze completions
##    Formula 2: 37% cloze completions
##    Formula 3: 35% cloze completions
##    Formula 4: 36% cloze completions
## 
## 
## Coleman-Liau
##   Parameters: default 
##          ECP: 33% (estimted cloze percentage)
##        Grade: 14.1 
##        Grade: 14.1 (short formula)
## 
## 
## Danielson-Bryan
##   Parameters: default 
##          DB1: 9.86 
##          DB2: 26.39 
##        Grade: &gt;= 13 (college) 
## 
## 
## Dickes-Steiwer's Handformel
##   Parameters: default 
##          TTR: 0.53 
##        Score: 32.21 
## 
## 
## Easy Listening Formula
##   Parameters: default 
##       Exsyls: 222 
##        Score: 12.33 
## 
## 
## Farr-Jenkins-Paterson
##   Parameters: default 
##           RE: 33.19 
##        Grade: &gt;= 13 (college) 
## 
## 
## Flesch Reading Ease
##   Parameters: en (Flesch) 
##           RE: 33.98 
##        Grade: &gt;= 13 (college) 
## 
## 
## Flesch-Kincaid Grade Level
##   Parameters: default 
##        Grade: 16.19 
##          Age: 21.19 
## 
## 
## Gunning Frequency of Gobbledygook (FOG)
##   Parameters: default 
##        Grade: 18.69 
## 
## 
## FORCAST
##   Parameters: default 
##        Grade: 10.99 
##          Age: 15.99 
## 
## 
## Fucks' Stilcharakteristik
##        Score: 162.11 
##        Grade: 12.73 
## 
## 
## Linsear Write
##   Parameters: default 
##   Easy words: 80.4 
##   Hard words: 19.6 
##        Grade: 21.5 
## 
## 
## Läsbarhetsindex (LIX)
##   Parameters: default 
##        Index: 65.24 
##       Rating: very difficult 
##        Grade: &gt; 11 
## 
## 
## Neue Wiener Sachtextformeln
##   Parameters: default 
##        nWS 1: 10.57 
##        nWS 2: 11.07 
##        nWS 3: 10.58 
##        nWS 4: 11.89 
## 
## 
## Readability Index (RIX)
##   Parameters: default 
##        Index: 10.61 
##        Grade: &gt; 12 (college) 
## 
## 
## Simple Measure of Gobbledygook (SMOG)
##   Parameters: default 
##        Grade: 17.19 
##          Age: 22.19 
## 
## 
## Strain Index
##   Parameters: default 
##        Index: 15.5 
## 
## 
## Tränkle-Bailer Formulas
##    Parameters: default 
##  Prepositions: 13%
##  Conjunctions: 3%
##          TB 1: 18.59 
##          TB 2: 27.15 
## 
## 
## Kuntzsch's Text-Redundanz-Index
##   Parameters: default 
##  Short words: 334 
##  Punctuation: 78 
##      Foreign: 0 
##        Score: -56.88 
## 
## 
## Tuldava's Text Difficulty Formula
##   Parameters: default 
##        Index: 5.74 
## 
## 
## Wheeler-Smith
##   Parameters: default 
##        Score: 123.33 
##        Grade: &gt; 4 
## 
## Text language: en</code></pre>
<p>To get a more condensed overview of the results try the <code>summary()</code> method:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(readbl.txt)</code></pre></div>
<pre><code>## Text language: en</code></pre>
<pre><code>##                    index     flavour    raw           grade  age
## 1                    ARI                              18.73     
## 2             Coleman C1                 39                     
## 3             Coleman C2                 37                     
## 4             Coleman C3                 35                     
## 5             Coleman C4                 36                     
## 6           Coleman-Liau                 33            14.1     
## 7    Danielson-Bryan DB1               9.86                     
## 8    Danielson-Bryan DB2              26.39 &gt;= 13 (college)     
## 9         Dickes-Steiwer              32.21                     
## 10                   ELF              12.33                     
## 11 Farr-Jenkins-Paterson              33.19 &gt;= 13 (college)     
## 12                Flesch en (Flesch)  33.98 &gt;= 13 (college)     
## 13        Flesch-Kincaid                              16.19 21.2
## 14                   FOG                              18.69     
## 15               FORCAST                              10.99   16
## 16                 Fucks             162.11           12.73     
## 17         Linsear-Write                               21.5     
## 18                   LIX              65.24            &gt; 11     
## 19                  nWS1                              10.57     
## 20                  nWS2                              11.07     
## 21                  nWS3                              10.58     
## 22                  nWS4                              11.89     
## 23                   RIX              10.61  &gt; 12 (college)     
## 24                  SMOG                              17.19 22.2
## 25                Strain               15.5                     
## 26   Traenkle-Bailer TB1              18.59                     
## 27   Traenkle-Bailer TB2              27.15                     
## 28                   TRI             -56.88                     
## 29               Tuldava               5.74                     
## 30         Wheeler-Smith             123.33             &gt; 4</code></pre>
<p>The <code>summary()</code> method supports an additional flat format, which basically turns the table into a named numeric vector, using the raw values (because all indices have raw values, but only a few more than that). This format comes very handy when you want to use the output in further calculations:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(readbl.txt, <span class="dt">flat=</span><span class="ot">TRUE</span>)</code></pre></div>
<pre><code>##                   ARI            Coleman.C1            Coleman.C2 
##                 18.73                 39.00                 37.00 
##            Coleman.C3            Coleman.C4          Coleman.Liau 
##                 35.00                 36.00                 33.00 
##   Danielson.Bryan.DB1   Danielson.Bryan.DB2        Dickes.Steiwer 
##                  9.86                 26.39                 32.21 
##                   ELF Farr.Jenkins.Paterson                Flesch 
##                 12.33                 33.19                 33.98 
##        Flesch.Kincaid                   FOG               FORCAST 
##                 16.19                 18.69                 10.99 
##                 Fucks         Linsear.Write                   LIX 
##                162.11                 21.50                 65.24 
##                  nWS1                  nWS2                  nWS3 
##                 10.57                 11.07                 10.58 
##                  nWS4                   RIX                  SMOG 
##                 11.89                 10.61                 17.19 
##                Strain   Traenkle.Bailer.TB1   Traenkle.Bailer.TB2 
##                 15.50                 18.59                 27.15 
##                   TRI               Tuldava         Wheeler.Smith 
##                -56.88                  5.74                123.33</code></pre>
<p>If you’re interested in a particular formula, again a wrapper function might be more convenient:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">flesch.res &lt;-<span class="st"> </span><span class="kw">flesch</span>(tagged.text, <span class="dt">hyphen=</span>hyph.txt.en)
lix.res &lt;-<span class="st"> </span><span class="kw">LIX</span>(tagged.text)   <span class="co"># LIX doesn't need syllable count</span>
lix.res</code></pre></div>
<pre><code>## 
## Läsbarhetsindex (LIX)
##   Parameters: default 
##        Index: 65.24 
##       Rating: very difficult 
##        Grade: &gt; 11 
## 
## Text language: en</code></pre>
<div id="readability-from-numeric-data" class="section level3">
<h3>Readability from numeric data</h3>
<p>It is possible to calculate the readability measures from the relevant key values directly, rather than analyze an actual text, by using <code>readability.num()</code> instead of <code>readability()</code>. If you need to reanalyze a particular text, this can be considerably faster. Therefore, all objects returned by <code>readability()</code> can directly be fed to <code>readability.num()</code>, since all relevant data is present in the <code>desc</code> slot.</p>
</div>
</div>
<div id="language-detection" class="section level2">
<h2>Language detection</h2>
<p>Another feature of this package is the detection of the language a text was (most probably) written in. This is done by gzipping reference texts in known languages, gzipping them again with addition of a small sample of the text in unknown language, and determining the case where the additional sample causes the smallest increase in file size <span class="citation">(as described in Benedetto, Caglioti, &amp; Loreto, 2002)</span>. By default, the compressed objects will be created in memory only.</p>
<p>To use the function <code>guess.lang()</code>, you first need to download the reference material. In this implementation, the Universal Declaration of Human Rights in unicode formatting is used, because the document holds the world record of beeing the text translated into the most languages, and is <a href="https://www.unicode.org/udhr/downloads.html">publicly available</a>. Please get the zipped archive with all translations in .txt format. You can, but don’t have to unzip the archive. The text to find the language of must also be in a unicode .txt file:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">guessed &lt;-<span class="st"> </span><span class="kw">guess.lang</span>(
  <span class="kw">file.path</span>(<span class="kw">find.package</span>(<span class="st">&quot;koRpus&quot;</span>),<span class="st">&quot;tests&quot;</span>,<span class="st">&quot;testthat&quot;</span>,<span class="st">&quot;sample_text.txt&quot;</span>),
  <span class="dt">udhr.path=</span><span class="st">&quot;~/downloads/udhr_txt.zip&quot;</span>
)
<span class="kw">summary</span>(guessed)</code></pre></div>
<pre><code>##   Estimated language: English
##           Identifier: eng
##               Region: Europe
## 
## 435 different languages were checked.
## 
## Distribution of compression differences:
##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##   136.0   168.0   176.0   190.7   184.0   280.0 
## 
##   SD: 38.21 
## 
## Top 5 guesses:
##                         name iso639-3 bcp47 region diff  diff.std
## 1                    English      eng    en Europe  136 -1.430827
## 2                      Scots      sco   sco Europe  136 -1.430827
## 3           Pidgin, Nigerian      pcm   pcm Africa  144 -1.221473
## 4   Catalan-Valencian-Balear      cat    ca Europe  152 -1.012119
## 5                     French      fra    fr Europe  152 -1.012119
## 
## Last 5 guesses:
##                         name iso639-3   bcp47 region diff diff.std
## 431                  Burmese      mya      my   Asia  280 2.337547
## 432                     Shan      shn     shn   Asia  280 2.337547
## 433                    Tamil      tam      ta   Asia  280 2.337547
## 434     Vietnamese (Han nom)      vie vi-Hani   Asia  280 2.337547
## 435             Chinese, Yue      yue     yue   Asia  280 2.337547</code></pre>
</div>
</div>
<div id="extending-korpus" class="section level1">
<h1>Extending <code>koRpus</code></h1>
<p>The language support of this package has a modular design. There are some pre-built language packages in <a href="https://undocumeantit.github.io/repos/">the <code>l10n</code> repository</a>, and with a little effort you should be able to add new languages yourself. You need the package sources for this, then basically you will have to add a new file to it and rebuild/reinstall the package. More details on this topic can be found in <code>inst/README.languages</code>. Once you got a new language to work with <code>koRpus</code>, I’d be happy to include your module in the official distribution.</p>
</div>
<div id="analyzing-full-corpora" class="section level1">
<h1>Analyzing full corpora</h1>
<p>Despite its name, the scope of <code>koRpus</code> is single texts. If you would like to do analysis an a full corpus of texts, have a look at the <a href="https://github.com/unDocUMeantIt/tm.plugin.koRpus">plugin package <code>tm.plugin.koRpus</code></a>.</p>
</div>
<div id="acknowledgements" class="section level1">
<h1>Acknowledgements</h1>
<p>The APA style used in this vignette was kindly provided by the <a href="http://CitationStyles.org">CSL project</a>, licensed under <a href="https://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike 3.0 Unported license</a>.</p>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references">
<div id="ref-benedetto_gzip_2002">
<p>Benedetto, D., Caglioti, E., &amp; Loreto, V. (2002). Language trees and zipping. <em>Physical Review Letters</em>, <em>88</em>(4), 048702.</p>
</div>
<div id="ref-bormuth_cloze_1968">
<p>Bormuth, J. R. (1968). Cloze Test Readability: Criterion Reference Scores. <em>Journal of Educational Measurement</em>, <em>5</em>(3), 189–196.</p>
</div>
<div id="ref-dale_formula_1948">
<p>Dale, E., &amp; Chall, J. S. (1948). A formula for predicting readability. <em>Educational Research Bulletin</em>, 11–28.</p>
</div>
<div id="ref-liang_word_1983">
<p>Liang, F. M. (1983). <em>Word Hy-phen-a-tion by Com-put-er</em> (Dissertation). Stanford University, Dept. Computer Science, Stanford.</p>
</div>
<div id="ref-maas_ueber_1972">
<p>Maas, H. D. (1972). Über den Zusammenhang zwischen Wortschatzumfang und Länge eines Textes. <em>Zeitschrift Für Literaturwissenschaft Und Linguistik</em>, <em>2</em>(8), 73–79.</p>
</div>
<div id="ref-mccarthy_vocd_2007">
<p>McCarthy, P. M., &amp; Jarvis, S. (2007). vocd – A theoretical and empirical evaluation. <em>Language Testing</em>, <em>24</em>(4), 459–488.</p>
</div>
<div id="ref-mccarthy_mtld_2010">
<p>McCarthy, P. M., &amp; Jarvis, S. (2010). MTLD, vocd-D, and HD-D: A validation study of sophisticated approaches to lexical diversity assessment. <em>Behavior Research Methods</em>, <em>42</em>(2), 381–392.</p>
</div>
<div id="ref-quasthoff_LCC_2006">
<p>Quasthoff, U., Richter, M., &amp; Biemann, C. (2006). Corpus Portal for Search in Monolingual Corpora. In <em>Proceedings of the Fifth International Conference on Language Resources and Evaluation</em> (pp. 1799–1802). Genoa.</p>
</div>
<div id="ref-schmid_TT_1994">
<p>Schmid, H. (1994). Probabilistic part-of-speec tagging using decision trees. In <em>International Conference on New Methods in Language Processing</em> (pp. 44–49). Manchester, UK.</p>
</div>
<div id="ref-spache_new_1953">
<p>Spache, G. (1953). A new readability formula for primary-grade reading materials. <em>The Elementary School Journal</em>, <em>53</em>(7), 410–413.</p>
</div>
<div id="ref-tweedie_how_1998">
<p>Tweedie, F. J., &amp; Baayen, R. H. (1998). How variable may a constant be? Measures of lexical richness in perspective. <em>Computers and the Humanities</em>, <em>32</em>(5), 323–352.</p>
</div>
</div>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>For a free implementation try <a href="http://strawberryperl.com" class="uri">http://strawberryperl.com</a><a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Like <a href="http://7-zip.org" class="uri">http://7-zip.org</a><a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>Unfortunately, these language packages did not get the approval of the CRAN maintainers and are officially hosted at (<a href="https://undocumeantit.github.io/repos/l10n" class="uri">https://undocumeantit.github.io/repos/l10n</a>)[<a href="https://undocumeantit.github.io/repos/l10n" class="uri">https://undocumeantit.github.io/repos/l10n</a>]. For your convenience the function <code>install.koRpus.lang()</code> can be used to easily install them anyway.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>Presets are defined in the language support packages, usually named like their respective two-character language identifier. Refer to their documentation.<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>For informtaion on the measures shown see <span class="citation">Tweedie &amp; Baayen (1998)</span>, <span class="citation">McCarthy &amp; Jarvis (2007)</span>, <span class="citation">McCarthy &amp; Jarvis (2010)</span>.<a href="#fnref5">↩</a></p></li>
<li id="fn6"><p>Characteristics can be looked at to examine each measure’s dependency on text length. They are calculated by computing each measure repeatedly, beginning with only the first token, then adding the next, progressing until the full text was analyzed.<a href="#fnref6">↩</a></p></li>
<li id="fn7"><p>The package also has a function called <code>read.corp.custom()</code> which can be used to process language corpora yourself, and store the results in an object of class <code>kRp.corp.freq</code>, which is the class returned by <code>read.corp.LCC()</code> and <code>read.corp.celex()</code> as well. That is, if you can’t get any already analyzed corpus database but have a huge language corpus at hand, you can create your own frequency database. But be warned that depending on corpus size and your hardware, this might take ages. On the other hand, <code>read.corp.custom()</code> will provide inverse document frequency (idf) values for all types, which is necessary to compute tf-idf with <code>freq.analysis()</code><a href="#fnref7">↩</a></p></li>
<li id="fn8"><p>Actually, it unterstands two different LCC formats, both the older .zip and the newer .tar archive format.<a href="#fnref8">↩</a></p></li>
<li id="fn9"><p>This can easily be done by calling <code>as(freq.analysis.res, &quot;kRp.tagged&quot;)</code>.<a href="#fnref9">↩</a></p></li>
<li id="fn10"><p>This sorting depends on proper POS-tagging, so this will only contain useful data if you used <code>treetag()</code> instead of <code>tokenize()</code>.<a href="#fnref10">↩</a></p></li>
<li id="fn11"><p>And can then be corrected by using the function <code>correct.tag()</code><a href="#fnref11">↩</a></p></li>
<li id="fn12"><p>Whether this is the case can be looked up in the documentation.<a href="#fnref12">↩</a></p></li>
<li id="fn13"><p>The <code>hyphen()</code> method was originally implemented as part of the <code>koRpus</code> package, but was later split off into its own package called <code>sylly</code>.<a href="#fnref13">↩</a></p></li>
<li id="fn14"><p>For example, this can be comfortably done with RKWard: <a href="https://rkward.kde.org" class="uri">https://rkward.kde.org</a><a href="#fnref14">↩</a></p></li>
<li id="fn15"><p>Please note that as of version 0.04-18, the correctness of some of these calculations has not been extensively validated yet. The package was released nonetheless, also to find outstanding bugs in the implemented measures. Any information on the validity of its results is very welcome!<a href="#fnref15">↩</a></p></li>
<li id="fn16"><p>Measures which rely on word lists will be skipped if no list is provided.<a href="#fnref16">↩</a></p></li>
</ol>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
